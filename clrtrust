#!/usr/bin/bash
# Copyright 2017 Intel Corporation

##### HEALTH CHECKS

function is_root {
    if [ $UID -ne 0 ]; then
        1>&2 echo "Must be root to execute the command."
        return 127
    fi
    return 0
}

function has_openssl {
    command -v openssl >/dev/null 2>&1
    if [ $? -ne 0 ]; then
        1>&2 echo "openssl is required, but not found."
        return 127
    fi
    return 0
}

# takes cert file as a single argument
# returns 0 if root ca, 1 otherwise
function is_root_ca {
    # if issuer and subject match, then it's a self-signed certificate, the only
    # indication of a Root CA we need to take into account (X.509v3 extensions
    # are not)
    t=`openssl x509 -in $1 -noout -issuer -subject 2>/dev/null      \
            | sed -e 's/^\(issuer\|subject\)=//' | uniq | wc -l`
    test $t -eq 1
    return $?
}

function is_number {
    case $1 in
        ''|*[!0-9]*) # not a number, return
            return 0
            ;;
        *)
            return 1
            ;;
    esac
}

##### DEFAULT LOCATIONS

# trust store default location
CLR_TRUST_STORE_DFLT=/var/cache/ca-certs
CLR_TRUST_STORE=${CLR_TRUST_STORE:-$CLR_TRUST_STORE_DFLT}

# user-supplied, local source of trust
CLR_LOCAL_TRUST_SRC=${CLR_LOCAL_TRUST_SRC:-/etc/ca-certs}

# Clear Linux-supplied source of trust
CLR_CLEAR_TRUST_SRC=${CLR_CLEAR_TRUST_SRC:-/usr/share/ca-certs}

# takes single argument: a directory
# the caller should grab the stdout of the call, it will contain found cert info
# in form of:
# <file name>\t<sha-256 fingerprint>
function find_certs {
    local dir
    dir=$1
    if [ -z $dir ]; then return 255; fi
    if [ ! -d $dir ]; then return 255; fi
    find $dir -maxdepth 1 -type f | while read f; do
        finger=`openssl x509 -in "${f}" -noout -fingerprint -sha256 2>/dev/null`
        if [ $? -ne 0 ]; then
            1>&2 echo "ERROR: file ${f} is not a certificate"
            continue
        fi
        finger=`echo $finger | sed -e 's/^SHA256 Fingerprint=//'`
        # NB: BEWARE: literal tab char in the string below
        echo "${f}	${finger}"
    done
    return 0
}

function find_all_certs {
    find_certs $CLR_CLEAR_TRUST_SRC/trusted
    find_certs $CLR_LOCAL_TRUST_SRC/trusted
}

function print_generate_help {
    cat <<EOF
Usage: ${BASENAME} generate

    This command does not take arguments.

    The store is generated from the following locations:
        ${CLR_CLEAR_TRUST_SRC}/trusted
        ${CLR_LOCAL_TRUST_SRC}/trusted
        ${CLR_LOCAL_TRUST_SRC}/distrusted
EOF
}

function cmd_generate {
    local ca_certs
    local dup_certs
    local distrust_certs
    local ca_certs_cnt
    local distrust_certs_cnt

    while [ $# -gt 0 ]; do
        case $1 in
            -h|--help)
                print_generate_help
                return 0
                ;;
            *)
                print_generate_help
                return 1
                ;;
        esac
    done
    # find all the certificates
    ca_certs=`find_all_certs`

    # handle the duplicates
    dup_certs=`echo "${ca_certs}" | cut -f 2 | sort | uniq -D`
    echo "$dup_certs"
    if [ ! -z "$dup_certs" ]; then
        #FIXME: remove dups, warn
        true
    fi

    # remove the distrusted ones
    distrust_certs=`find_certs $CLR_LOCAL_TRUST_SRC/distrusted`
    ca_certs_cnt=`echo "$ca_certs" | wc -l`
    distrust_certs_cnt=`echo "$distrust_certs" | wc -l`
    if [ $distrust_certs_cnt -gt 0 ]; then
        echo "Distrusting $distrust_certs_cnt certificate(s)."
        for h in `echo "$distrust_certs" | cut -f 2`; do
            ca_certs=`echo "$ca_certs" | grep -v $h`
        done
    fi

    # write the store
    umask 022

    CLR_STORE_STAGE=`mktemp -u`
    mkdir $CLR_STORE_STAGE
    mkdir $CLR_STORE_STAGE/anchors
    mkdir $CLR_STORE_STAGE/compat

    echo "${ca_certs}" | cut -f 1 | xargs -I '{}' cp '{}' $CLR_STORE_STAGE/anchors

    pushd $CLR_STORE_STAGE/anchors >/dev/null
    c_rehash . >/dev/null 2>&1
    if [ $? -ne 0 ]; then
        1>&2 echo "Error rehashing the anchors."
        exit 1
    fi
    popd >/dev/null

    TMP=`mktemp -u`
    mv $CLR_TRUST_STORE $TMP
    mv $CLR_STORE_STAGE $CLR_TRUST_STORE
    rm -rf $TMP

    echo "Trust store generated at ${CLR_TRUST_STORE}"
    return 0
}

function print_add_help {
    cat <<EOF
Usage: ${BASENAME} add <file>

    file        file containing a PEM-encoded Root CA certificate
EOF
}

function cmd_add {
    local files
    local ret
    local ca_certs
    local err_pipe
    local tmp
    while [ $# -gt 0 ]; do
        case $1 in
            -h|--help)
                print_add_help
                return 0
                ;;
            *)
                # first empty line will be deleted few lines later
                files="$files
$1"
                shift
                ;;
        esac
    done
    if [ -z "$files" ]; then
        1>&2 echo "Specify certificate(s) to add."
        print_add_help
        return 128
    fi
    files=`echo "$files" | sed -e '1d'`
    ca_certs=`find_all_certs`
    err_pipe=`mktemp -u`
    tmp=`mktemp`
    mkfifo $err_pipe
    echo "$files" | while read f; do
        if [ ! -f "$f" ]; then
            echo "No such file $f."
            # get the certificate from the list
            # TODO: get the file, assign it to files
            continue
        fi
        finger=`openssl x509 -in "${f}" -noout -fingerprint -sha256 2>$tmp`
        if [ $? -ne 0 ]; then
            echo "$f is not an X.509 certificate."
            cat $tmp
            continue
        fi
        finger=`echo $finger | sed -e 's/^SHA256 Fingerprint=//'`
        is_root_ca "$f"
        if [ $? -ne 0 ]; then
            cat <<EOF
Certificate $f is not a Root CA. Not adding intermediates or leaves.
EOF
            continue
        fi
        echo "$ca_certs" | grep $finger >/dev/null 2>&1
        if [ $? -eq 0 ]; then
            cat <<EOF
Certificate $f is already trusted. Not adding duplicates.
EOF
            continue
        fi
        fname=`basename $f`
        if [ -f $CLR_LOCAL_TRUST_SRC/trusted/$fname ]; then
            # FIXME: it's not a duplicate, should really not be picky about file
            # names.
            echo "File $fname already exists."
            continue
        fi
    done >$err_pipe &
    out=`cat $err_pipe`
    if [ -z "$out" ]; then
        echo "$files" | while read f; do
            cp "${f}" $CLR_LOCAL_TRUST_SRC/trusted
        done
        cmd_generate
    else
        ret=128
        1>&2 echo "$out"
    fi
    rm $err_pipe $tmp
    return $ret
}

function print_list_help {
    cat <<EOF
Usage: ${BASENAME} list

    Prints the list of certificates, each in form of
        id: <id>
            File: <filename>
            Authority: <issuer name>
            Expires: <expiration date>
EOF
}

function cmd_list {
    local certs
    local info
    local indent
    local err
    while [ $# -gt 0 ]; do
        case $1 in
            -h|--help)
                print_list_help
                return 0
                ;;
            *)
                print_list_help
                return 1
                ;;
        esac
        shift
    done
    # 4 spaces for sed
    indent="\ \ \ \ "
    if [ ! -d ${CLR_TRUST_STORE}/anchors ]; then
        1>&2 echo "${CLR_TRUST_STORE} is not a trust store." \
            " Use ${BASENAME} generate to create the store."
        return 128
    fi
    certs=`find ${CLR_TRUST_STORE}/anchors -maxdepth 1 -type f | LC_COLLATE=C sort`
    if [ -z "${certs}" ]; then
        test ! -z $VERBOSE && echo "Nothing is trusted. No anchors found in ${CLR_TRUST_STORE}."
        return 0
    fi

    echo "$certs" | while read f; do
        info=`openssl x509 -in "${f}" -noout -fingerprint -sha256 -issuer -enddate`
        if [ $? -ne 0 ]; then
            1>&2 echo "${f} is not an X.509 certificate."
        fi
        info=`echo "$info" |                                          \
            sed -e "s/^SHA256 Fingerprint=/id: /"                      \
                    -e "2i${indent}File: ${f}"                          \
                    -e "s/^issuer=\s*/${indent}Authority: /"             \
                    -e "s/^notAfter=\s*/${indent}Expires: /"`
        echo "$info"
    done

    return 0
}

function print_remove_help {
    cat <<EOF
Usage: ${BASENAME} remove [-f|--force] [filename|id]...

    Distrusts specified Certificate Authorities. Each CA can be represented
    either by a file containing PEM-encoded X.509 certificate or an id as
    obtained from the list command.

    -f | --force        Forces removal of certificates
    -h | --help         Prints this help message
EOF
}

function cmd_remove {
    local files
    local ids
    local err_pipe
    local out_pipe
    local invld_files
    local certs
    local opt_force
    while [ $# -gt 0 ]; do
        case $1 in
            -h|--help)
                print_remove_help
                return 0
                ;;
            -f|--force)
                # TODO: implement forcing
                opt_force=1
                true
                ;;
            *)
                if [ -f "$1" ]; then
                    # need newline as a separator in case filename comes with
                    # spaces. first empty line will be deleted later.
                    files="$files
$1"
                else
                    ids="$ids $1"
                fi
                ;;
        esac
        shift
    done

    err_pipe=`mktemp -u`
    out_pipe=`mktemp -u`
    mkfifo $err_pipe
    mkfifo $out_pipe
    files=`echo "$files" | sed -e '1d'`
    test ! -z "$files" && echo "$files" | while read f; do
        finger=`openssl x509 -in "${f}" -noout -fingerprint -sha256 2>/dev/null`
        if [ $? -ne 0 ]; then
            echo "${f}" >$err_pipe &
            continue
        fi
        echo "${crt}	${finger}" | sed -e 's/\tSHA256 Fingerprint=/\t/'
    done >$out_pipe &
    echo >$err_pipe &
    invld_files=`cat $err_pipe`
    if [ ! -z "$invld_files" ]; then
        # FIXME: handle
        echo "$invld_files"
    fi
    files=`cat $out_pipe`
    ids=`echo $ids && (echo "$files" | cut -f 2)`
    certs=`find_all_certs`
    for id in $ids; do
        f=`echo "$certs" | grep $id`
        if [ $? -eq 0 ]; then
            echo "$f" | cut -f 1
        else
            f=`echo "$files" | grep $id | cut -f 1`
            if [ -z $f ]; then
                1>&2 echo "Certificate id $id not found."
            else
                1>&2 echo "Certificate id $id not found (file: $f)."
            fi
        fi
    done >$out_pipe &
    files=`cat $out_pipe`
    if [ ! -z "$files" ]; then
        echo "$files" | while read f; do
            rm $f
        done
        cmd_generate
    else
        echo "Nothing to do."
    fi
    rm $err_pipe $out_pipe
    return 0
}

function print_help {
    cat <<EOF
Usage: ${BASENAME} [-v|--verbose] [-h|--help] <command> [options]

    Commands
        generate    generates the trust store
        list        list CAs
        add         add trust to a CA
        remove      remove trust to a CA
        restore     restore trust to previously removed CA
        check       sanity/consistency check of the trust store

${BASENAME} <command> --help to get help on specific command.
EOF
}

##### GLOBAL VARS/OPTIONS
VERBOSE=0
COMMAND=""
BASENAME=`basename $0` # this may not work, but we don't care too much
ARGS=$*

while [ $# -gt 0 ]; do
    opt=$1
    case $opt in
        -v|--verbose)
            VERBOSE=1
            ;;
        -h|--help)
            print_help
            exit 0
            ;;
        generate|list|add|remove|restore|check)
            COMMAND=$opt
            ;;
    esac
    shift
    if [ ! -z $COMMAND ]; then
        break
    fi
done

if [ -z $COMMAND ]; then
    1>&2 echo Command not understood: $ARGS
    print_help
    exit 128
fi

case $COMMAND in
    generate|add|remove|restore)
        # must be root if writing to the default location
        if [ "x$CLR_TRUST_STORE" = "x$CLR_TRUST_STORE_DFLT" ]; then
            is_root
            if [ $? -ne 0 ]; then
                exit 127
            fi
        fi
        ;;
esac

case $COMMAND in
    generate)
        cmd_generate $*
        exit $?
        ;;
    add)
        cmd_add $*
        exit $?
        ;;
    list)
        cmd_list $*
        exit $?
        ;;
    remove)
        cmd_remove $*
        exit $?
        ;;
    restore|check)
        1>&2 echo "$COMMAND not yet supported."
        exit 1
        ;;
esac

# vim: si:noai:nocin:tw=80:sw=4:ts=4:et:nu
