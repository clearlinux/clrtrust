#!/usr/bin/bash
# Copyright 2017 Intel Corporation

##### HEALTH CHECKS

function is_root {
    if [ $UID -ne 0 ]; then
        1>&2 echo "Must be root to execute the command."
        return 127
    fi
    return 0
}

function has_openssl {
    which openssl >/dev/null 2>&1
    if [ $? -ne 0 ]; then
        1>&2 echo "openssl is required, but not found."
        return 127
    fi
    return 0
}

function is_root_ca {
    # FIXME: implement
    return 1
}

function is_number {
    case $1 in
        ''|*[!0-9]*) # not a number, return
            return 0
            ;;
        *)
            return 1
            ;;
    esac
}

##### DEFAULT LOCATIONS

# trust store default location
CLR_TRUST_STORE_DFLT=/var/cache/ca-certs
CLR_TRUST_STORE=${CLR_TRUST_STORE:-$CLR_TRUST_STORE_DFLT}

# user-supplied, local source of trust
CLR_LOCAL_TRUST_SRC=${CLR_LOCAL_TRUST_SRC:-/etc/ca-certs}

# Clear Linux-supplied source of trust
CLR_CLEAR_TRUST_SRC=${CLR_CLEAR_TRUST_SRC:-/usr/share/ca-certs}

# takes single argument: a directory
# the caller should grab the stdout of the call, it will contain found cert info
# in form of:
# <file name>\t<sha-256 fingerprint>
function find_certs {
    local _dir
    _dir=$1
    if [ -z $_dir ]; then return 255; fi
    if [ ! -d $_dir ]; then return 255; fi
    (ls $_dir) | while read crt; do
        finger=`openssl x509 -in "${_dir}/${crt}" -noout -fingerprint -sha256 2>/dev/null`
        if [ $? -ne 0 ]; then
            1>&2 echo "ERROR: file ${crt} is not a certificate"
            continue
        fi
        finger=`echo $finger | sed -e 's/^SHA256 Fingerprint=//'`
        # NB: literal tab in the string below, DO NOT CHANGE
        echo "${_dir}/${crt}	${finger}"
    done
    return 0
}

function find_all_certs {
    find_certs $CLR_CLEAR_TRUST_SRC/trusted
    find_certs $CLR_LOCAL_TRUST_SRC/trusted
}

function print_generate_help {
    cat <<EOF
Usage: ${BASENAME} generate

    This command does not take arguments.

    The store is generated from the following locations:
        ${CLR_CLEAR_TRUST_SRC}/trusted
        ${CLR_LOCAL_TRUST_SRC}/trusted
        ${CLR_LOCAL_TRUST_SRC}/distrusted
EOF
}

function cmd_generate {
    local _ca_certs
    local _dup_certs
    local _distrust_certs
    local _ca_certs_cnt
    local _distrust_certs_cnt

    while [ $# -gt 0 ]; do
        case $1 in
            -h|--help)
                print_generate_help
                return 0
                ;;
            *)
                _cert=$1
                shift
                ;;
        esac
    done
    # find all the certificates
    _ca_certs=`find_all_certs`
    
    # handle the duplicates
    _dup_certs=`echo "${_ca_certs}" | cut -f 2 | sort | uniq -D`
    echo "$_dup_certs"
    if [ ! -z "$_dup_certs" ]; then
        #FIXME: remove dups, warn
        true
    fi

    # remove the distrusted ones
    _distrust_certs=`find_certs $CLR_LOCAL_TRUST_SRC/distrusted`
    _ca_certs_cnt=`echo "$_ca_certs" | wc -l`
    _distrust_certs_cnt=`echo "$_distrust_certs" | wc -l`
    if [ $_distrust_certs_cnt -gt 0 ]; then
        echo "Distrusting $_distrust_certs_cnt certificate(s)."
        for h in `echo "$_distrust_certs" | cut -f 2`; do
            _ca_certs=`echo "$_ca_certs" | grep -v $h`
        done
    fi

    # write the store
    umask 022

    CLR_STORE_STAGE=`mktemp -u`
    mkdir $CLR_STORE_STAGE
    mkdir $CLR_STORE_STAGE/anchors
    mkdir $CLR_STORE_STAGE/compat

    echo "${_ca_certs}" | cut -f 1 | xargs -I '{}' cp '{}' $CLR_STORE_STAGE/anchors

    pushd $CLR_STORE_STAGE/anchors >/dev/null
    c_rehash . >/dev/null 2>&1
    if [ $? -ne 0 ]; then
        1>&2 echo "Error rehashing the anchors."
        exit 1
    fi
    popd >/dev/null

    TMP=`mktemp -u`
    mv $CLR_TRUST_STORE $TMP
    mv $CLR_STORE_STAGE $CLR_TRUST_STORE
    rm -rf $TMP

    echo "Trust store generated at ${CLR_TRUST_STORE}"
    return 0
}

function print_add_help {
    cat <<EOF
Usage: ${BASENAME} add <file>

    file        file containing a PEM-encoded Root CA certificate
EOF
}

function cmd_add {
    local _cert
    local _basename
    local _opt_force
    local _out
    local _finger
    while [ $# -gt 0 ]; do
        case $1 in
            -h|--help)
                print_add_help
                return 0
                ;;
            -f|--force)
                _opt_force=1
                shift
                ;;
            *)
                _cert=$1
                shift
                ;;
        esac
    done
    if [ -z $_cert ]; then
        1>&2 echo "Specify certificate to add."
        print_add_help
        return 128
    fi
    if [ ! -f $_cert ]; then
        1>&2 echo "No such file $_cert."
        # get the certificate from the list
        # TODO: get the file, assign it to _cert
        return 128
    fi
    _out=`mktemp`
    _finger=`openssl x509 -in $_cert -noout -fingerprint -sha256 2>$_out \
            | sed -e 's/^SHA256 Fingerprint=//'`
    if [ $? -ne 0 ]; then
        1>&2 echo "$_cert is not a certificate."
        1>&2 cat $_out
        rm $_out
        return 128
    fi
    is_root_ca
    if [ $? -ne 1 ]; then
        1>&2 cat <<EOF
Certificate is not a Root CA. Not adding intermediates.
EOF
        return 128
    fi
    find_all_certs | grep $_finger >/dev/null 2>&1
    if [ $? -eq 0 ]; then
        1>&2 cat <<EOF
Certificate is already trusted. Not adding duplicates.
EOF
        return 128
    fi
    rm $_out
    _basename=`basename $_cert`
    if [ ! -f $CLR_LOCAL_TRUST_SRC/trusted/$_basename ]; then
        cp $_cert $CLR_LOCAL_TRUST_SRC/trusted
    else
        # FIXME: if it's not a duplicate, should really not be picky about
        # file names.
        1>&2 echo "File $_basename already exists."
    fi
    return 0
}

function print_list_help {
    cat <<EOF
Usage: ${BASENAME} list

    Prints the list of certificates, each in form of
        id: <id>
            File: <filename>
            Authority: <issuer name>
            Expires: <expiration date>
EOF
}

function cmd_list {
    local _certs
    local _id
    local _info
    local _indent
    while [ $# -gt 0 ]; do
        case $1 in
            -h|--help)
                print_list_help
                return 0
                ;;
        esac
    done
    _id=1
    _indent="    "
    if [ ! -d ${CLR_TRUST_STORE}/anchors ]; then
        1>&2 echo "${CLR_TRUST_STORE} is not a trust store." \
            " Use ${BASENAME} generate to create the store."
        return 128
    fi
    _certs=`find ${CLR_TRUST_STORE}/anchors -maxdepth 1 -type f | LC_COLLATE=C sort`
    if [ -z ${_certs} ]; then
        test ! -z $VERBOSE && echo "Nothing is trusted. No anchors found in ${CLR_TRUST_STORE}."
        return 0
    fi

    echo "$_certs" | while read _crt; do
        _info=`openssl x509 -in ${_crt} -noout -issuer -enddate \
            | sed -e "s/^issuer=\s*/${_indent}Authority: /" -e "s/^notAfter=\s*/${_indent}Expires: /"`
        if [ $? -ne 0 ]; then
            1>&2 echo "${_crt} is not an X.509 certificate."
        fi
        cat <<EOF
id: ${_id}
${_indent}File: ${_crt}
EOF
        echo "$_info"
        let "_id+=1"
    done

    return 0

}

function print_help {
    cat <<EOF
Usage: ${BASENAME} [-v|--verbose] [-h|--help] <command> [options]

    Commands
        generate    generates the trust store
        add         add trust to a CA
        remove      remove trust to a CA
        restore     restore trust to previously removed CA
        check       sanity/consistency check of the trust store

${BASENAME} <command> --help to get help on specific command.
EOF
}

##### GLOBAL VARS/OPTIONS
VERBOSE=0
COMMAND=""
BASENAME=`basename $0`
ARGS=$*

while [ $# -gt 0 ]; do
    opt=$1
    case $opt in
        -v|--verbose)
            VERBOSE=1
            ;;
        -h|--help)
            print_help
            exit 0
            ;;
        generate|list|add|remove|restore|check)
            COMMAND=$opt
            ;;
    esac
    shift
    if [ ! -z $COMMAND ]; then
        break
    fi
done

if [ -z $COMMAND ]; then
    1>&2 echo Command not understood: $ARGS
    print_help
    exit 128
fi

case $COMMAND in
    generate|add|remove|restore)
        # must be root if writing to the default location
        echo $CLR_TRUST_STORE
        if [ "x$CLR_TRUST_STORE" = "x$CLR_TRUST_STORE_DFLT" ]; then
            is_root
            if [ $? -ne 0 ]; then
                exit 127
            fi
        fi
        ;;
esac

case $COMMAND in
    generate)
        cmd_generate $*
        exit $?
        ;;
    add)
        cmd_add $*
        exit $?
        ;;
    list)
        cmd_list $*
        exit $?
        ;;
    remove|restore|check)
        1>&2 echo "$COMMAND not yet supported."
        exit 1
        ;;
esac

# vim: si:noai:nocin:tw=80:sw=4:ts=4:et:nu
