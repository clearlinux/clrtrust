#!/usr/bin/bash
# Copyright 2017 Intel Corporation

##### HEALTH CHECKS

function is_root {
    if [ $UID -ne 0 ]; then
        1>&2 echo "Must be root to execute the command."
        return 127
    fi
    return 0
}

function has_openssl {
    command -v openssl >/dev/null 2>&1
    if [ $? -ne 0 ]; then
        1>&2 echo "openssl is required, but not found."
        return 127
    fi
    return 0
}

function is_root_ca {
    # FIXME: implement
    return 1
}

function is_number {
    case $1 in
        ''|*[!0-9]*) # not a number, return
            return 0
            ;;
        *)
            return 1
            ;;
    esac
}

##### DEFAULT LOCATIONS

# trust store default location
CLR_TRUST_STORE_DFLT=/var/cache/ca-certs
CLR_TRUST_STORE=${CLR_TRUST_STORE:-$CLR_TRUST_STORE_DFLT}

# user-supplied, local source of trust
CLR_LOCAL_TRUST_SRC=${CLR_LOCAL_TRUST_SRC:-/etc/ca-certs}

# Clear Linux-supplied source of trust
CLR_CLEAR_TRUST_SRC=${CLR_CLEAR_TRUST_SRC:-/usr/share/ca-certs}

# takes single argument: a directory
# the caller should grab the stdout of the call, it will contain found cert info
# in form of:
# <file name>\t<sha-256 fingerprint>
function find_certs {
    local _dir
    _dir=$1
    if [ -z $_dir ]; then return 255; fi
    if [ ! -d $_dir ]; then return 255; fi
    find $_dir -maxdepth 1 -type f | while read _crt; do
        finger=`openssl x509 -in "${_crt}" -noout -fingerprint -sha256 2>/dev/null`
        if [ $? -ne 0 ]; then
            1>&2 echo "ERROR: file ${_crt} is not a certificate"
            continue
        fi
        finger=`echo $finger | sed -e 's/^SHA256 Fingerprint=//'`
        # NB: BEWARE: literal tab char in the string below
        echo "${_crt}	${finger}"
    done
    return 0
}

function find_all_certs {
    find_certs $CLR_CLEAR_TRUST_SRC/trusted
    find_certs $CLR_LOCAL_TRUST_SRC/trusted
}

function print_generate_help {
    cat <<EOF
Usage: ${BASENAME} generate

    This command does not take arguments.

    The store is generated from the following locations:
        ${CLR_CLEAR_TRUST_SRC}/trusted
        ${CLR_LOCAL_TRUST_SRC}/trusted
        ${CLR_LOCAL_TRUST_SRC}/distrusted
EOF
}

function cmd_generate {
    local _ca_certs
    local _dup_certs
    local _distrust_certs
    local _ca_certs_cnt
    local _distrust_certs_cnt

    while [ $# -gt 0 ]; do
        case $1 in
            -h|--help)
                print_generate_help
                return 0
                ;;
            *)
                _cert=$1
                shift
                ;;
        esac
    done
    # find all the certificates
    _ca_certs=`find_all_certs`
    
    # handle the duplicates
    _dup_certs=`echo "${_ca_certs}" | cut -f 2 | sort | uniq -D`
    echo "$_dup_certs"
    if [ ! -z "$_dup_certs" ]; then
        #FIXME: remove dups, warn
        true
    fi

    # remove the distrusted ones
    _distrust_certs=`find_certs $CLR_LOCAL_TRUST_SRC/distrusted`
    _ca_certs_cnt=`echo "$_ca_certs" | wc -l`
    _distrust_certs_cnt=`echo "$_distrust_certs" | wc -l`
    if [ $_distrust_certs_cnt -gt 0 ]; then
        echo "Distrusting $_distrust_certs_cnt certificate(s)."
        for h in `echo "$_distrust_certs" | cut -f 2`; do
            _ca_certs=`echo "$_ca_certs" | grep -v $h`
        done
    fi

    # write the store
    umask 022

    CLR_STORE_STAGE=`mktemp -u`
    mkdir $CLR_STORE_STAGE
    mkdir $CLR_STORE_STAGE/anchors
    mkdir $CLR_STORE_STAGE/compat

    echo "${_ca_certs}" | cut -f 1 | xargs -I '{}' cp '{}' $CLR_STORE_STAGE/anchors

    pushd $CLR_STORE_STAGE/anchors >/dev/null
    c_rehash . >/dev/null 2>&1
    if [ $? -ne 0 ]; then
        1>&2 echo "Error rehashing the anchors."
        exit 1
    fi
    popd >/dev/null

    TMP=`mktemp -u`
    mv $CLR_TRUST_STORE $TMP
    mv $CLR_STORE_STAGE $CLR_TRUST_STORE
    rm -rf $TMP

    echo "Trust store generated at ${CLR_TRUST_STORE}"
    return 0
}

function print_add_help {
    cat <<EOF
Usage: ${BASENAME} add <file>

    file        file containing a PEM-encoded Root CA certificate
EOF
}

function cmd_add {
    local _files
    local _basename
    local _ret
    local _finger
    local _ca_certs
    while [ $# -gt 0 ]; do
        case $1 in
            -h|--help)
                print_add_help
                return 0
                ;;
            *)
                _files="$_files
$1"
                shift
                ;;
        esac
    done
    if [ -z "$_files" ]; then
        1>&2 echo "Specify certificate(s) to add."
        print_add_help
        return 128
    fi
    _files=`echo "$_files" | sed -e '1d'`
    _ca_certs=`find_all_certs`
    _err_pipe=`mktemp -u`
    _tmp=`mktemp`
    mkfifo $_err_pipe
    echo "$_files" | while read f; do
        if [ ! -f "$f" ]; then
            echo "No such file $f."
            # get the certificate from the list
            # TODO: get the file, assign it to _files
            continue
        fi
        _finger=`openssl x509 -in "$f" -noout -fingerprint -sha256 2>$_tmp`
        if [ $? -ne 0 ]; then
            echo "$f is not an X.509 certificate."
            cat $_tmp
            continue
        fi
        _finger=`echo $_finger | sed -e 's/^SHA256 Fingerprint=//'`
        is_root_ca
        if [ $? -ne 1 ]; then
            cat <<EOF
Certificate $f is not a Root CA. Not adding intermediates.
EOF
            continue
        fi
        echo "$_ca_certs" | grep $_finger >/dev/null 2>&1
        if [ $? -eq 0 ]; then
            cat <<EOF
Certificate $f is already trusted. Not adding duplicates.
EOF
            continue
        fi
        _basename=`basename $f`
        if [ -f $CLR_LOCAL_TRUST_SRC/trusted/$_basename ]; then
            # FIXME: it's not a duplicate, should really not be picky about file
            # names.
            echo "File $_basename already exists."
            continue
        fi
    done >$_err_pipe &
    _out=`cat $_err_pipe`
    if [ -z "$_out" ]; then
        echo "$_files" | while read f; do
            cp "$f" $CLR_LOCAL_TRUST_SRC/trusted
        done
        cmd_generate
    else
        _ret=128
        1>&2 echo "$_out"
    fi
    rm $_err_pipe $_tmp
    return $_ret
}

function print_list_help {
    cat <<EOF
Usage: ${BASENAME} list

    Prints the list of certificates, each in form of
        id: <id>
            File: <filename>
            Authority: <issuer name>
            Expires: <expiration date>
EOF
}

function cmd_list {
    local _certs
    local _id
    local _info
    local _indent
    local _err
    while [ $# -gt 0 ]; do
        case $1 in
            -h|--help)
                print_list_help
                return 0
                ;;
            *)
                print_list_help
                return 1
                ;;
        esac
        shift
    done
    # 4 spaces for sed
    _indent="\ \ \ \ "
    if [ ! -d ${CLR_TRUST_STORE}/anchors ]; then
        1>&2 echo "${CLR_TRUST_STORE} is not a trust store." \
            " Use ${BASENAME} generate to create the store."
        return 128
    fi
    _certs=`find ${CLR_TRUST_STORE}/anchors -maxdepth 1 -type f | LC_COLLATE=C sort`
    if [ -z ${_certs} ]; then
        test ! -z $VERBOSE && echo "Nothing is trusted. No anchors found in ${CLR_TRUST_STORE}."
        return 0
    fi

    echo "$_certs" | while read _crt; do
        _info=`openssl x509 -in ${_crt} -noout -fingerprint -sha256 -issuer -enddate`
        if [ $? -ne 0 ]; then
            1>&2 echo "${_crt} is not an X.509 certificate."
        fi
        _info=`echo "$_info" |                                          \
            sed -e "s/^SHA256 Fingerprint=/id: /"                        \
                    -e "2i${_indent}File: ${_crt}"                        \
                    -e "s/^issuer=\s*/${_indent}Authority: /"              \
                    -e "s/^notAfter=\s*/${_indent}Expires: /"`
        echo "$_info"
    done

    return 0
}

function print_remove_help {
    cat <<EOF
Usage: ${BASENAME} remove [-f|--force] [filename|id]...

    Distrusts specified Certificate Authorities. Each CA can be represented
    either by a file containing PEM-encoded X.509 certificate or an id as
    obtained from the list command.

    -f | --force        Forces removal of certificates
    -h | --help         Prints this help message
EOF
}

function cmd_remove {
    local _files
    local _ids
    local _err_pipe
    local _out_pipe
    local _invld_files
    local _certs
    local _opt_force
    while [ $# -gt 0 ]; do
        case $1 in
            -h|--help)
                print_remove_help
                return 0
                ;;                    
            -f|--force)
                # TODO: implement forcing
                _opt_force=1
                true
                ;;
            *)
                if [ -f "$1" ]; then
                    # need newline as a separator in case filename comes with
                    # spaces. first empty line will be deleted later.
                    _files="$_files
$1"
                else
                    _ids="$_ids $1"
                fi
                ;;
        esac
        shift
    done

    _err_pipe=`mktemp -u`
    _out_pipe=`mktemp -u`
    mkfifo $_err_pipe
    mkfifo $_out_pipe
    _files=`echo "$_files" | sed -e '1d'`
    test ! -z "$_files" && echo "$_files" | while read _crt; do
        finger=`openssl x509 -in "$_crt" -noout -fingerprint -sha256 2>/dev/null`
        if [ $? -ne 0 ]; then
            echo $_crt >>$_err_pipe &
            echo "$_crt is not an X.509 certificate"
            continue
        fi
        echo "${_crt}	${finger}" | sed -e 's/\tSHA256 Fingerprint=/\t/' >>$_out_pipe &
    done
    echo >>$_out_pipe &
    echo >>$_err_pipe &
    _invld_files=`cat $_err_pipe`
    if [ ! -z $_invld_files ]; then
        echo $_invld_files
    fi
    _files=`cat $_out_pipe`
    _ids=`echo $_ids && (echo "$_files" | cut -f 2)`
    _certs=`find_all_certs`
    for _id in $_ids; do
        f=`echo "$_certs" | grep $_id`
        if [ $? -eq 0 ]; then
            echo "$f" | cut -f 1 >>$_out_pipe &
        else
            f=`echo "$_files" | grep $_id | cut -f 1`
            if [ -z $f ]; then
                1>&2 echo "Certificate id $_id not found."
            else
                1>&2 echo "Certificate id $_id not found (file: $f)."
            fi
        fi
    done
    echo >>$_out_pipe &
    _files=`cat $_out_pipe`
    if [ ! -z $_files ]; then
        echo "$_files" | while read f; do
            echo $f
            rm $f
        done
        cmd_generate
    else 
        echo "Nothing to do."
    fi
    rm $_err_pipe $_out_pipe
    return 0
}

function print_help {
    cat <<EOF
Usage: ${BASENAME} [-v|--verbose] [-h|--help] <command> [options]

    Commands
        generate    generates the trust store
        list        list CAs
        add         add trust to a CA
        remove      remove trust to a CA
        restore     restore trust to previously removed CA
        check       sanity/consistency check of the trust store

${BASENAME} <command> --help to get help on specific command.
EOF
}

##### GLOBAL VARS/OPTIONS
VERBOSE=0
COMMAND=""
BASENAME=`basename $0`
ARGS=$*

while [ $# -gt 0 ]; do
    opt=$1
    case $opt in
        -v|--verbose)
            VERBOSE=1
            ;;
        -h|--help)
            print_help
            exit 0
            ;;
        generate|list|add|remove|restore|check)
            COMMAND=$opt
            ;;
    esac
    shift
    if [ ! -z $COMMAND ]; then
        break
    fi
done

if [ -z $COMMAND ]; then
    1>&2 echo Command not understood: $ARGS
    print_help
    exit 128
fi

case $COMMAND in
    generate|add|remove|restore)
        # must be root if writing to the default location
        if [ "x$CLR_TRUST_STORE" = "x$CLR_TRUST_STORE_DFLT" ]; then
            is_root
            if [ $? -ne 0 ]; then
                exit 127
            fi
        fi
        ;;
esac

case $COMMAND in
    generate)
        cmd_generate $*
        exit $?
        ;;
    add)
        cmd_add $*
        exit $?
        ;;
    list)
        cmd_list $*
        exit $?
        ;;
    remove)
        cmd_remove $*
        exit $?
        ;;
    restore|check)
        1>&2 echo "$COMMAND not yet supported."
        exit 1
        ;;
esac

# vim: si:noai:nocin:tw=80:sw=4:ts=4:et:nu
